<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, intial-scale=1.0">
        <title>Rolling wheel</title>
        <style> /* Internal CSS styling. */
            *{ /* Universal selector. */
                margin: 0; /* Remove default margin. */
                padding: 0; /* Remove default padding. */
                box-sizing: border-box; /* Include border and padding in element's total width and height. */
            }
            #wrapper{ /* id selector. */
                width: 100vw; /* 100% of the viewport's width. */
                height: 100vh; /* 100% of the viewport's height. */
                display: flex; /* Flexbox layout. */
                flex-direction: column; /* Stack children vertically. */
                overflow: hidden; /* Hide overlow content, no scrollbars. */
            }
            header{ /* Type selector. */
                width: 100%; /* 100% of the parent's width. */
                height: 70px; /* Fixed height. */
                background: seaGreen; /* Your choice. */
                display: flex; /* Flexbox layout. */
                justify-content: space-evenly; /* Even horizontal spacing. */
                align-items: center; /* Vertical centering. */
                font: 2vw Arial; /* Responsive font. */
            }
            figure{ /* Type selector. */
                width: 100%; /* 100% of the parent's width. */
                height: 100%; /* All remaining free height 100vh - 70px. */
                background-color: paleGreen; /* Your choice. */
                position: relative; /* For abosolute positioning of canvas. */
            }
            canvas{ /* Type selector. */
                position: relative;
            }
        </style>
    </head>
    <body>
        <div id="wrapper"> <!-- Top-level container. Wrapps everything. -->
            <header> <!-- Semantic HTML element. -->
                <div> <!-- Control container. -->
                    Wheel radius: <span class="wheel-radius">60</span> px<br>
                    <input type="range" class="wheel-radius" min="10" max="150" value="100" autocomplete="off">
                </div>
            </header>
            <figure> <!-- Semantic element. Canvas container. -->
                <canvas></canvas>
            </figure>
        </div>
        <script> // Embedded JavaScript.
//*************************** GLOBAL VARIABLES **********************
const headerElem = document.querySelector('header'); // References to DOM elements, for convenience. 
const inputRadiusElem = document.querySelector('input.wheel-radius');
const figureElem = document.querySelector('figure');
const canvasElem = document.querySelector('canvas');
const ctx = canvasElem.getContext('2d'); // 2D rendering context.
const π = Math.PI; // Shortcut. 'π' alt code 227.
let lastTime; // Timestamp of last animation frame.
let animationId; // Stores requestAnimationFrame ID.
const gravity = 0.0003, rollingResistance = 0.999; // Physics parameters.
const wheel = {     // Object representing wheel.
    x:undefined,    // Current x. 
    y:undefined,    // Current y.
    radius: Number(inputRadiusElem.value), // Radius from input element.
    velX: 0,        // Horizontal velocity.
    velY: 0,        // Vertical velocity. 
    rotation: 0,    // Current rotation angle.
    angularVel: 0,  // Angular velocity.
    fillStyle: undefined, // Fill style.
}
const terrain = []; // Array to store terray height (y) values (indexes correspond to x values). 
//*************************** EVENTS ********************************
inputRadiusElem.addEventListener('change',e=>{ // Change wheel radius.
    wheel.radius = Number(e.target.value); // Update wheel.radius
    document.querySelector('span.wheel-radius').textContent = wheel.radius; // Update display.
    initialize(); // Reinitialize simulation.
});
//*************************** LOGIC *********************************
function renderWheel(){ // Draws the wheel on canvas.
    ctx.save();                         // Save current canvas state.
    ctx.translate(wheel.x,wheel.y);     // Move origin to wheel center.
    ctx.rotate(wheel.rotation);         // Apply curren rotation.
    ctx.beginPath();                    // Star new path.
    ctx.arc(0,0,wheel.radius,0,2*π);    // Draw wheel circle.
    ctx.fillStyle = wheel.fillStyle;    // Set fill style.
    ctx.fill();                         // Fill the wheel.
    ctx.restore();                      // Restore canvas state.
}
function renderTerrain(){   // Renders the terrain.
    const {width:W, height:H} = canvasElem; // Destructuring syntax. Declare W,H shortcuts for convenience.
    ctx.beginPath();                // Start new path.
    ctx.fillStyle = 'green';        // Set terrain color.
    ctx.moveTo(0,H);                // Start an bottom-left.
    for(let x = 0; x < W; x += 2){  // Loop through x positions.
        ctx.lineTo(x,terrain[x]);   // Draw line to terrain height.
    }
    ctx.lineTo(W,H);                // Complete path to bottom-right.
    ctx.closePath();                // Close path.
    ctx.fill();                     // Fill terrain.
}
function repeatingConicGradient(repeat = 7){ // Creates a conic gradient for wheel.
    const gradient = ctx.createConicGradient(0,0,0); // Create a gradient centered at (0,0).
    for(let i = 0; i < repeat; i++){ // Create repeating pattern.
        const pos = i*1/repeat; // Calculate position.
        gradient.addColorStop(pos,'yellow');              // Add color stop.
        gradient.addColorStop(pos+1/(3*repeat),'maroon'); // Add color stop.
        gradient.addColorStop(pos+2/(3*repeat),'yellow'); // Add color stop.
    }
    return gradient; // Return constructed gradient.
}
function findContactPoint() { // Find wheel's contact point with terrain.
    const contactX = terrain // x coordinate of contact point.
        .entries() // Get terrain entries.
        .filter(([i,y])=>{return !(i < wheel.x-wheel.radius-3 || i > wheel.x+wheel.radius+3)}) // Filter points near wheel.
        .map(([i,y])=>{ // Map do distance squaered. Index preserved.
            const dx = i-wheel.x;
            const dy = y-wheel.y;
            return [i,dx*dx+dy*dy];
        })
        .reduce((closest,[i,distSq])=>{ // Find closest point.
            return distSq < closest[1] ? [i,distSq] : closest; // Ternary operator, to find closest point.
        },[null,Infinity])[0]; // Initial value, and [0] selects index, which is effectevelly the x coordinate.
    const x1 = Math.max(0,contactX-5); // Left point for slope calculation.
    const x2 = Math.min(canvasElem.width-1,contactX+5); // Right point for slope calculation.
    return{ // Return object representing contact point.
        x: contactX,
        y: terrain[contactX],
        angle: Math.atan2(terrain[x2]-terrain[x1],x2-x1), // Slope angle at contact point.
    }
}
function updateWheel(t) { // Update wheel physics.
    const contact = findContactPoint(); // Get current contact point.
    const slope = contact.angle; // Get terrain slope.
    const acceleration = gravity * Math.sin(slope); // Acceleration from gravity.
    // Apply physics.
    wheel.velX += acceleration*t*Math.cos(slope);
    wheel.velX *= rollingResistance;
    wheel.velY += acceleration*t*Math.sin(slope);
    wheel.angularVel = wheel.velX/wheel.radius;
    // Move wheel position first.
    wheel.x += wheel.velX*t;
    wheel.y += wheel.velY*t;
    
    const [dx,dy] = [wheel.x-contact.x,wheel.y-contact.y];// Calculate vector from contact point to wheel center.
    const distance = Math.sqrt(dx*dx + dy*dy); // Distance from contact to center (can remove Math.sqrt to optimize for speed).
    
    if (wheel.radius-distance > 1) {// If wheel is penetrating terrain (distance < radius).
        const correction = wheel.radius - distance;  // Calculate correction vector.
        const [nx,ny] = [dx/distance,dy/distance]; // Normalized normal vector.
        // Reposition wheel center along normal.
        wheel.x += nx*correction;
        wheel.y += ny*correction;
        // Velocity correction to conserve energy.
        const dot = wheel.velX*nx+wheel.velY*ny; // Dot product of velocity and normal.
        wheel.velX -= 2.0*dot*nx; // Reflect x velocity.
        wheel.velY -= 2.0*dot*ny; // Reflect y velocity.
    }
    wheel.rotation += wheel.angularVel*t; // Update rotation.
}
function initialize(){ // (Re)initializes simulation.
    cancelAnimationFrame(animationId); // Cancel animation (if any).
    const {width:W,height:H} = canvasElem; // Destructuring syntax. Shortcuts.
    const a = W*.5, b = H*.4; // Ellipse (terrain line) semi major and minor axis.
    terrain.length = 0; // Clear terrain array.
    for(let x = -a; x <= a; x++){ // Loop through elipse x coodinates.
        terrain[x+a] = H/2+b*Math.sqrt(1-(x/a)**2); // Semi-elliptical terrain.
    }
    wheel.x = wheel.radius; wheel.y = H/2; // Initial wheel possition.
    wheel.velX = 0; wheel.velY = 0;  // REset velocities.
    wheel.rotation = 0; wheel.angularVel = 0; // Reset rotation.
    wheel.fillStyle = repeatingConicGradient(3); // Set wheel fillStyle as conic gradient.
    lastTime = undefined; // Reset animation timing.
    animatinId = requestAnimationFrame(animate); // Start animation/simulation.
}
function animate(timestamp){ // Main animation loop.
    if(!lastTime) lastTime = timestamp; // Initializes lastTime on first frame.
    const frameTime = timestamp-lastTime; // Time since last frame.
    lastTime = timestamp; // Update last time.
    ctx.clearRect(0,0,canvasElem.width,canvasElem.height); // Clear canvas.
    updateWheel(frameTime); // Update wheel physics.
    renderWheel(); // Draw wheel.
    renderTerrain(); // Draw terrain.
    animationId = requestAnimationFrame(animate); // Continue animation.
}
//*************************** INITIALIZATION ************************
onload = ()=>{ // When page loads.
    [canvasElem.width,canvasElem.height] = [figureElem.offsetWidth,figureElem.offsetHeight]; // Destructoring syntax. Set canvas dimensions.
    initialize(); // Initialize and starts simulation.
}
//*******************************************************************
        </script>
    </body>
</html>